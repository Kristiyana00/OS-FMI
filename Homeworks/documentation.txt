Източници:
Използвани са само man страниците на командите, които са ме интересували.
--------------------------------------------------------------------------
Домашно №1:

#Създаваме shell script с име unpack.sh.
--------------------------------------------------------------------------
#!/bin/bash 
#Конкретизираме, че ще се изпълнява от bash.

#Проверяваме дали са подадени някакви аргументи. Ако няма подадени никакви аргументи, извеждаме подходящо съобщение.
if [ $# -eq 0 ]
then
        echo "No arguments! Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
        exit 1
fi

#Ако броят на аргументите не е равен на 4, извеждаме подходящо съобщение, което дава информация за търсения формат на използване на скрипта.
if [ $# -ne 4 ]
then
        echo "Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
        exit 1
fi

#Създаваме променлива, която държи в себе си името на архива, който ще разархивираме.
#Използваме cut, за да вземем само името на архива, а не целия път.
FILE_ARCHIVE=$(echo "${1}" | rev | cut -d '/' -f 1 | rev)

#Създаваме променлива, която да използваме за проверката дали подаденият архив съществува.
#Намираме пътя на архива чрез името му.
FILE_TO_TEST=$(find ~ -name "${FILE_ARCHIVE}")

#Правим проверка дали архивът съществува.
if [ -e "$FILE_TO_TEST" ]
then
	#Ако архивът съществува, правим проверка дали е в zip формат. Ако форматът не е zip, извеждаме грешка и подходящо съобщение.
	#Използваме grep -q, за да не принтим информация на изхода.
        if ( ! egrep -q 'Zip archive data' < <(file "${FILE_TO_TEST}") );
        then
                echo "First argument error: Enter a zip file!"
                echo "Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
                exit 1
        fi
else
	#Ако архивът не съществува, извеждаме грешка и подходящо съобщение, което дава информация за търсения формат на използване на скрипта.
        echo "First argument error: Enter an existent zip file!"
        echo "Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
        exit 1
fi

#Правим проверка дали вторият подаден аргумент е директория и дали съществува. Ако съществува, извеждаме грешка и подходящо съобщение, понеже по условие директорията не трябва да съществува.
if [ -d $2 ]
then
        echo "Second argument error: Enter a non-existent dir name!"
        echo "Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
        exit 1
fi

#Правим проверка дали третият подаден аргумент е директория и дали съществува. Ако съществува, извеждаме грешка и подходящо съобщение, понеже по условие директорията не трябва да съществува.
if [ -d $3 ]
then
        echo "Third argument error: Enter a non-existent dir name!"
        echo "Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
        exit 1
fi

#Правим проверка дали четвъртият подаден аргумент е файл и дали съществува. Ако съществува, извеждаме грешка и подходящо съобщение, понеже по условие файлът не трябва да съществува.
if [ -e $4 ]
then
        echo "Fourth argument error: Enter a non-existent file name!"
        echo "Please enter 4 arguments: <name of zip file> <non-existent dir name> <non-existent dir name> <non-existent file name>"
        exit 1
fi

#След като сме направили всички възможни проверки, започваме обработването на подадените файлове.
#Създаваме променливи, към които присвояваме подадените в скрипта аргументи.
#За променливата ARCHIVE използваме вече създадената променлива FILE_TO_TEST, понеже тя държи информация за абсолютния път на вече намерения съществуващ архив.
ARCHIVE="${FILE_TO_TEST}"
#DIR - папката, в която ще разархивираме подадения архив.
DIR="${2}"
#FAILED_DIR - папката, в която ще прехвърлим fail-натите резултати.
FAILED_DIR="${3}"
#FILe - файлът, в който ще записваме резултатите от всеки успешно обработен архив.
FILE="${4}"

#Създаваме папките и файла.
mkdir -p "${DIR}"
mkdir -p "${FAILED_DIR}"
touch "${FILE}"

#Разархивираме архива като с флага -d указваме в коя папка да разархивираме.
unzip "${ARCHIVE}" -d "${DIR}" 2>/dev/null

#В папката, в която разархивирахме архива, намираме всички подпапки и сменяме имената им, така че да се състоят само от факулететен номер.
#Завъртаме един while цикъл и за всеки ред вземаме факултетния номер и променяме името на директорията с него.
find "${DIR}" -mindepth 1 -maxdepth 1 2>/dev/null | while read line; do
        mv "${line}" $(dirname "${line}")/$(echo "${line}" | rev | cut -d '/' -f 1,1 | rev | cut -d '-' -f 1);
done

#В папката, която разархивираме, търсим файловете само на същото ниво. С флага %f на printf принтираме само basename на файловете. След това сортираме числово и въртим while цикъл, чрез който записваме всички факултетни номера сортирани в подадения в скрипта файл.
find "${DIR}" -mindepth 1 -maxdepth 1 -printf "%f\n" 2>/dev/null | sort -n | while read line; do
        echo "${line}" >> "${FILE}"
done

#Създаваме променливата GRI с mktemp, която отговаря за информацията дали името или разширението на архива е грешно. 
#Ако името на архива или разширението е грешно - пишем 1, иначе - 0.
GRI=$(mktemp)

#За всеки сортиран намерен ред проверяваме дали името на архива и разширението му са грешни.
while read line; do
	#Ако архивът няма разширение ".tar.xz" -> попълваме 1 на съответния ред във файла с резултатите.
        if echo $line | egrep -vq ".tar.xz$"; then
                echo "1" >> "${GRI}"
	#Ако името на архива е грешно -> попълваме 1 на съответния ред във файла с резултатите.
	#Сравняваме дали името на архива съвпада с името на папката.
        elif [ $(dirname "${line}" | rev | cut -d '/' -f 1,1 |rev) != $(basename "${line}" | cut -d '.' -f 1,1)  ]; then
                echo "1" >> "${GRI}"
	#Ако името на архива и разширението му са верни -> пишем 0 на съответния ред във файла с резултатите.
        else
                echo "0" >> "${GRI}"
        fi
done < <(find "${DIR}" -mindepth 2 -maxdepth 2 2>/dev/null | sort -n)

#Създаваме временен файл TOCOPY, който ще използваме, за да присъединим информацията от двата файла (с факултетните номера и с <гри> информацията).
TOCOPY=$(mktemp)
#Paste-ваме двата файла като чрез флага -d указваме, че искаме делимитър спейс. Резултатът се записва в новосъздадения временен файл TOCOPY.
paste -d ' ' "${FILE}" "${GRI}" > "${TOCOPY}"

#Присвояваме записаната във временния файл информация на FILE, който е финалният файл с резултати.
mv "${TOCOPY}" "${FILE}"

#Създаваме временен файл GRF, който отговаря за информацията дали форматът на архива е грешен.
GRF=$(mktemp)

#За всеки прочетен ред правим проверка дали типът на файла е 'XZ compressed data', който е верният формат за архив.
while read line; do
	#Правим проверка дали въпросният прочетен ред е от тип 'XZ compressed data' и ако е, записваме 0 във файла с резултатите за <грф>.
        if egrep -q 'XZ compressed data' < <(file "${line}"); then
                echo "0" >> "${GRF}"
	#Ако форматът не е 'XZ compressed data', записваме 1 във файла с резултатите за <грф>.
        else
                echo "1" >> "${GRF}"
        fi
done < <(find "${DIR}" -mindepth 2 -maxdepth 2 2>/dev/null | sort -n)

#Създаваме временен файл TOCOPY, който ще използваме, за да присъединим информацията от двата файла (с факултетните номера и с <грф> информацията).
TOCOPY=$(mktemp)
#Paste-ваме двата файла като чрез флага -d указваме, че искаме делимитър спейс. Резултатът се записва в новосъздадения временен файл TOCOPY.
paste -d ' ' "${FILE}" "${GRF}" > "${TOCOPY}"

#Присвояваме записаната във временния файл информация на FILE, който е финалният файл с резултати.
mv "${TOCOPY}" "${FILE}"

#За всеки прочетен ред правим проверка какъв тип е архива, за да знаем кой деархиватор да използваме.
while read line; do
	#Ако типът на архива е 'Zip archive data', тогава използваме unzip. 
        if egrep -q 'Zip archive data' < <(file "${line}"); then
		#Използваме флага -qq, за да не принтим излишна информация на изхода. С флага -d указваме директорията, в която искаме да разархивираме архива.
                unzip -qq "${line}" -d $(dirname "${line}") 2>/dev/null
		#Ако получим exit status, различен от 0, то тогава не сме успели да разархивираме архива и го местим в папката с fail-нати резултати.
                if [ $? -ne 0 ]; then
			#Чрез флага -r на cp, копираме рекурсивно.
                        cp -r $(dirname "${line}") "${FAILED_DIR}"
                fi
	#Ако типът на архива е 'RAR archive data', тогава използваме unrar. 
        elif egrep -q 'RAR archive data' < <(file "${line}"); then
		#Чрез флага x разархивираме файловете с целия им път. С флага -inul забраняваме принтирането на всякакви съобщения на изхода. 
                unrar x -inul "${line}" $(dirname "${line}") 2>/dev/null
		#Ако получим exit status, различен от 0, то тогава не сме успели да разархивираме архива и го местим в папката с fail-нати резултати.
                if [ $? -ne 0 ]; then
                        cp -r $(dirname "${line}") "${FAILED_DIR}"
                fi
	#В останалите случаи ще използваме tar.
        else
		#Чрез флага -x разархивираме архива, а чрез флага -C указваме в коя папка да се случи това.
                tar -xf "${line}" -C $(dirname "${line}") 2>/dev/null
		#Ако получим exit status, различен от 0, то тогава не сме успели да разархивираме архива и го местим в папката с fail-нати резултати.
                if [ $? -ne 0 ]; then
                        cp -r $(dirname "${line}") "${FAILED_DIR}"
                fi
        fi
done < <(find "${DIR}" -mindepth 2 -maxdepth 2 2>/dev/null | sort -n)

#Създаваме временен файл HD, който отговаря за информацията дали липсва директория в архива.
HD=$(mktemp)
#Създаваме временен файл GRD, който отговаря за информацията дали името на директорията на архива е грешно.
GRD=$(mktemp)

#За всеки прочетен ред правим проверка дали името на директорията в архива е грешно и дали директорията липсва или съществува.
while read line; do
	#Проверяваме дали прочетения ред има подпапки, като ако резултатът е 0 -> директорията липсва, следователно и името на директорията е грешно.
        if [ $(find "${line}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | egrep '[0-9]+$' | wc -l) -eq 0 ]; then
		#Записваме 1 във файла с резултатите за <нд> понеже директорията липсва.
                echo "1" >> "${HD}"
		#Записваме 1 във файла с резултатите за <грд> понеже името на директорията е грешно.
                echo "1" >> "${GRD}"
        else
	#В противен случай, ако съществува директория, записваме 0 във файла с резултатите за <нд> и правим проверка дали името е във верния формат.
                echo "0" >> "${HD}"
		#Имената на parent и child трябва да съвпадат, за да е валидно името.
		#Взимаме името на parent.
                parent=$(find "${line}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | cut -d '/' -f 2)
		#Взимаме името на child.
                child=$(find "${line}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | cut -d '/' -f 3)
		
		#Сравняваме двете променливи.
                if [ "${parent}" == "${child}" ]; then
			#Ако имената съвпадат, то записваме 0 във файла с резултатите за <грд>.
                        echo "0" >> "${GRD}"
                else
			#Ако имената не съвпадат, то записваме 1 във файла с резултатите за <грд>.
                        echo "1" >> "${GRD}"
                fi
        fi
done < <(find "${DIR}" -mindepth 1 -maxdepth 1 2>/dev/null | sort -n)

#Създаваме временен файл TOCOPY, който ще използваме, за да присъединим информацията от двата файла (с факултетните номера и с <нд> информацията).
TOCOPY=$(mktemp)
#Paste-ваме двата файла като чрез флага -d указваме, че искаме делимитър спейс. Резултатът се записва в новосъздадения временен файл TOCOPY.
paste -d ' ' "${FILE}" "${HD}" > "${TOCOPY}"

#Присвояваме записаната във временния файл информация на FILE, който е финалният файл с резултати.
mv "${TOCOPY}" "${FILE}"

#Създаваме временен файл TOCOPY, който ще използваме, за да присъединим информацията от двата файла (с факултетните номера и с <грд> информацията).
TOCOPY=$(mktemp)
#Paste-ваме двата файла като чрез флага -d указваме, че искаме делимитър спейс. Резултатът се записва в новосъздадения временен файл TOCOPY.
paste -d ' ' "${FILE}" "${GRD}" > "${TOCOPY}"

#Присвояваме записаната във временния файл информация на FILE, който е финалният файл с резултати.
mv "${TOCOPY}" "${FILE}"

exit 0
